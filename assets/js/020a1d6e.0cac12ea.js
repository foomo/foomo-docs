"use strict";(self.webpackChunkfoomo=self.webpackChunkfoomo||[]).push([[3174],{6066:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>s,default:()=>d,frontMatter:()=>c,metadata:()=>i,toc:()=>l});var a=n(5893),o=n(3905);const c={},s="Caching",i={id:"projects/cms/gocontentful/caching",title:"Caching",description:"Caching is a fundamental part of working with remote data across the Internet,",source:"@site/docs/projects/cms/gocontentful/05-caching.md",sourceDirName:"projects/cms/gocontentful",slug:"/projects/cms/gocontentful/caching",permalink:"/docs/projects/cms/gocontentful/caching",draft:!1,unlisted:!1,editUrl:"https://github.com/foomo/foomo-docs/tree/main/foomo/docs/projects/cms/gocontentful/05-caching.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{},sidebar:"projectsSidebar",previous:{title:"Working with the Gocontentful API",permalink:"/docs/projects/cms/gocontentful/working-with-gocontentful-api"},next:{title:"API Reference",permalink:"/docs/projects/cms/gocontentful/api-reference"}},r={},l=[{value:"Full cache init and rebuild",id:"full-cache-init-and-rebuild",level:4},{value:"Sync API support",id:"sync-api-support",level:4},{value:"Cache timeout",id:"cache-timeout",level:3},{value:"Asset caching",id:"asset-caching",level:3},{value:"When to use and not use caching",id:"when-to-use-and-not-use-caching",level:3}];function h(e){const t={a:"a",code:"code",em:"em",h1:"h1",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.ah)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"caching",children:"Caching"}),"\n",(0,a.jsx)(t.p,{children:"Caching is a fundamental part of working with remote data across the Internet,\nwhere access is severely impacted by latency and transfer time. In real-world scenarios,\nyou'll always need to keep all the data you need close and sync the changes with the remote\nCMS when they happen."}),"\n",(0,a.jsx)(t.p,{children:"Gocontentful supports caching out of the box. The client can maintain a cache of an entire space\nor a subset of the content types that can be initialized with a single method call:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-go",children:'contentTypes := []string{"person", "pet"}\nerr = cc.UpdateCache(context, contentTypes, true)\n'})}),"\n",(0,a.jsxs)(t.p,{children:["This makes sense for client modes ",(0,a.jsx)(t.code,{children:"ClientModeCDA"})," and ",(0,a.jsx)(t.code,{children:"ClientModeCPA"})," and not for the management API.\nThe client will download all the entries, convert and store them in the case as\nnative Go value objects. This makes subsequent accesses to the space data an in-memory operation removing all the HTTP\noverhead."]}),"\n",(0,a.jsxs)(t.p,{children:["The first parameter is the context. If you don't use a context in your application or service just pass ",(0,a.jsx)(t.em,{children:"context.Background()"})]}),"\n",(0,a.jsx)(t.p,{children:"The third parameter of UpdateCache toggles asset caching on or off. If you deal with assets you want this to be always on."}),"\n",(0,a.jsx)(t.h4,{id:"full-cache-init-and-rebuild",children:"Full cache init and rebuild"}),"\n",(0,a.jsx)(t.p,{children:"By default the client will cache the whole space using 4 parallel workers to speed up the process.\nThis is safe since Contentful allows up to 5 concurrent connections.\nIf you have content types that have a lot of entries, it might make sense to keep them close to each other\nin the content types slice passed to UpdateCache(), so that they will run in parallel and not one after the other."}),"\n",(0,a.jsxs)(t.p,{children:["All gocontentful functions that query the space cache-transparent: if a cache is available data will be loaded from\nthere, otherwise it will be sourced from Contentful. This doesn't apply to ",(0,a.jsx)(t.em,{children:"GetFilteredXYZ()"})," calls that\nalways need to pass the query to Contentful."]}),"\n",(0,a.jsx)(t.p,{children:"Gocontentful also supports selective entry and asset cache updates through the following method:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-go",children:"err = cc.UpdateCacheForEntity(context, sysType, contentType, entityID string)\n"})}),"\n",(0,a.jsx)(t.p,{children:"When something changes in the space at Contentful you need to update the cache. For this to happen you need to set\nup a webhook at Contentful and handle its calls in your service through a public HTTP listener.\nWhen a webhook call gets in, you have the choice of updating your cache in different ways:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"You can regenerate the entire CDA cache when something is published because you want production data to\nbe 100% up to date in your application. This can get slow and expensive."}),"\n",(0,a.jsx)(t.li,{children:"You can alternatively update a single entry in the cache. This is usually the case for the CPA cache because\nit's a lot faster and that works well for preview features."}),"\n",(0,a.jsxs)(t.li,{children:["You can use the Sync API, but only limited to ",(0,a.jsx)(t.code,{children:"ClientModeCDA"}),", as explained in the following paragraph."]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["In any case, if an update fails the previous cache is preserved to prevent service disruption.\nIn the unfortunate case a service or application needs to start and Contentful is not available, Gocontentful can work\nin an offline mode if you call ",(0,a.jsx)(t.em,{children:"SetOfflineFallback"})," on the client after you create it passing the path to a space export file."]}),"\n",(0,a.jsx)(t.p,{children:"The gocontentful API can work entirely offline too. In this case a cache is created from a space export file and most of the\nfeatures are available (pretty obviously, those that don't require live access to the space, like custom queries). If you update\nthe export file periodically you can even update the cache from the updated file."}),"\n",(0,a.jsx)(t.h4,{id:"sync-api-support",children:"Sync API support"}),"\n",(0,a.jsx)(t.p,{children:"In versions v1.0.12 and newer, gocontentful supports the Contentful Sync API and that's now the recommended way to cache spaces and manage updates.\nSync is enabled by default when you create a client with CDA mode.\nTo enable or disable support for the Sync API explicitly, you can call the SetSyncMode method on the client:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-go",children:"cc.SetSyncMode(true)\n"})}),"\n",(0,a.jsxs)(t.p,{children:["With sync on, the cache updates will happen transparently through downloads of incremental changes.\nThe syntax to update the cache doesn't change, just call ",(0,a.jsx)(t.em,{children:"UpdateCache"})," on the client as usual."]}),"\n",(0,a.jsxs)(t.p,{children:["The initialization of the cache will be slower when ",(0,a.jsx)(t.em,{children:"SyncMode"})," is on compared to the legacy full cache init because sync calls cannot be parallelized.\nSubsequent updates though will be much faster because only changes in the space from the previous sync will be downloaded.\nThis includes entries and assets that were deleted. In case of need you can call ",(0,a.jsx)(t.em,{children:"ResetSync()"})," to start over from a fresh empty cache."]}),"\n",(0,a.jsx)(t.p,{children:"Note that the Sync API is not officially supported by Contentful on the Preview API. At the time of this writing it seems to work but use it at your own risk."}),"\n",(0,a.jsx)(t.h3,{id:"cache-timeout",children:"Cache timeout"}),"\n",(0,a.jsxs)(t.p,{children:["Cache update operations time out by default after 120 seconds. This makes sure that no\nroutine is left hanging, blocking subsequent updates in case the main application or service\nrecovers from a panic. If you need to increase this limit because you have a huge space with\na lot of entries you can use the ",(0,a.jsx)(t.em,{children:"SetCacheUpdateTimeout"})," method. See the ",(0,a.jsx)(t.a,{href:"./api-reference",children:"API Reference"})," for details."]}),"\n",(0,a.jsx)(t.h3,{id:"asset-caching",children:"Asset caching"}),"\n",(0,a.jsxs)(t.p,{children:["If you use assets in your space, then you absolutely need to enable them in the ",(0,a.jsx)(t.em,{children:"UpdateCache"})," call.\nOtherwise, every time an entry needs to resolve a reference to an asset that single asset will be downloaded\nand that for large spaces with thousands of assets can lead to incredibly slow operation."]}),"\n",(0,a.jsx)(t.h3,{id:"when-to-use-and-not-use-caching",children:"When to use and not use caching"}),"\n",(0,a.jsx)(t.p,{children:"Simple answer is: you should almost always use caching. The only scenario where not using\na cache on the client is better is when you only need to download a very limited amount\nof entries (in the order of less than some hundreds) and do that at significant distance in time\n(e.g. every hour). In this case your application code can be simpler and there won't be any\nperformance penalty. The other case is when you need to run a lot of custom queries or\nuse XPath, which is currently not supported by gocontentful directly."})]})}function d(e={}){const{wrapper:t}={...(0,o.ah)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},3905:(e,t,n)=>{n.d(t,{ah:()=>l});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},c=Object.keys(e);for(a=0;a<c.length;a++)n=c[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(e);for(a=0;a<c.length;a++)n=c[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var r=a.createContext({}),l=function(e){var t=a.useContext(r),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,c=e.originalType,r=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),u=l(n),p=o,f=u["".concat(r,".").concat(p)]||u[p]||h[p]||c;return n?a.createElement(f,s(s({ref:t},d),{},{components:n})):a.createElement(f,s({ref:t},d))}));d.displayName="MDXCreateElement"}}]);