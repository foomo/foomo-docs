"use strict";(self.webpackChunkfoomo=self.webpackChunkfoomo||[]).push([[5719],{4962:(r,e,t)=>{t.r(e),t.d(e,{assets:()=>a,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>c,toc:()=>l});var n=t(5893),o=t(3905);const s={},i="Errors",c={id:"projects/gotsrpc/service-interfaces/errors",title:"Errors",description:"Handling errors is always hard and you have to differentiate about some capabilites between server-to-server and server-to-frontend communications:",source:"@site/docs/projects/gotsrpc/service-interfaces/errors.md",sourceDirName:"projects/gotsrpc/service-interfaces",slug:"/projects/gotsrpc/service-interfaces/errors",permalink:"/docs/projects/gotsrpc/service-interfaces/errors",draft:!1,unlisted:!1,editUrl:"https://github.com/foomo/foomo-docs/tree/main/foomo/docs/projects/gotsrpc/service-interfaces/errors.md",tags:[],version:"current",frontMatter:{},sidebar:"projectsSidebar",previous:{title:"Value Objects",permalink:"/docs/projects/gotsrpc/service-interfaces/value-objects"},next:{title:"TypeScript client transport",permalink:"/docs/projects/gotsrpc/client-transport"}},a={},l=[{value:"Server to Server",id:"server-to-server",level:2},{value:"Server to Frontend",id:"server-to-frontend",level:2},{value:"String Error Types",id:"string-error-types",level:3},{value:"Struct Error Types",id:"struct-error-types",level:3}];function p(r){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.ah)(),...r.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h1,{id:"errors",children:"Errors"}),"\n",(0,n.jsx)(e.p,{children:"Handling errors is always hard and you have to differentiate about some capabilites between server-to-server and server-to-frontend communications:"}),"\n",(0,n.jsx)(e.h2,{id:"server-to-server",children:"Server to Server"}),"\n",(0,n.jsxs)(e.p,{children:["When using server to server communication you can use the regular go ",(0,n.jsx)(e.code,{children:"error"})," interface.\nSince interfaces are not typed but still need to be able to checked on the client side, gotsrpc will wrap them during the encode phase to keep the information using ",(0,n.jsx)(e.code,{children:"mapstructure"}),"."]}),"\n",(0,n.jsx)(e.p,{children:"NOTE: Be aware though, that private attributes on structs will be lost during transportation"}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:"language-go",children:'type CustomError struct {\n\tMessage string\n\tdata    string // will be lost\n}\n\nfunc (e *CustomError) Error() string {\n\treturn e.Message\n}\n\ntype Service interface {\n\tDo() (err error)\n}\n\nfunc main() {\n\t// ...\n\terr, clientErr := client.Do()\n\tif clientErr != nil {\n\t\tpanic("client error")\t\n\t}\n\t\n\t// you will be able to use errors.Is() or errors.As()\n\tvar customErr *CustomError\n\tif errors.As(err, &customErr) {\n\t\t// ...\t\n\t}\n\tif errors.Is(err, os.ErrExist) {\n\t\t// ...\n\t}\n}\n'})}),"\n",(0,n.jsx)(e.h2,{id:"server-to-frontend",children:"Server to Frontend"}),"\n",(0,n.jsx)(e.p,{children:"On the frontend side, everything needs to be strictly typed so sth like this, does not transport well, since an interface implementation can not be marshalled."}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:"language-go",children:"// from https://go.dev/blog/error-handling-and-go\ntype error interface {\n    Error() string\n}\n"})}),"\n",(0,n.jsx)(e.h3,{id:"string-error-types",children:"String Error Types"}),"\n",(0,n.jsx)(e.p,{children:"Scalar string error types provide a nice way to combine Go constants, that translate to TypeScript enums as errors:"}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:"language-go",metastring:'title="Go"',children:'type ScalarError string\n\nconst (\n    ErrorFoo ScalarError = "foo"\n    ErrorBar ScalarError = "bar"\n)\n\nfunc (e *ScalarError) Error() string {\n    return string(*e)\n}\n\ntype Service interface {\n    MightGoWrong() *ScalarError\n}\n'})}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:"language-typescript",metastring:'title="TypeScript"',children:'export enum ScalarError {\n\tErrorBar = "bar",\n\tErrorFoo = "foo",\n}\n\nexport interface ServiceClient {\n    mightGoWrong(): Promise<ScalarError | null>;\n}\n'})}),"\n",(0,n.jsx)(e.h3,{id:"struct-error-types",children:"Struct Error Types"}),"\n",(0,n.jsx)(e.p,{children:"If an enumeration is not enough and you want to add information to your errors a struct is a good choice (be careful not to expose secrets \ud83d\ude09) :"}),"\n",(0,n.jsxs)(e.ul,{children:["\n",(0,n.jsx)(e.li,{children:"it can still implement the Error type"}),"\n",(0,n.jsx)(e.li,{children:"it is still typed in contrast to other alternatives like maps"}),"\n"]}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:"language-go",metastring:'title="Go"',children:'type ErrorCode int\n\nconst (\n    ErrorCodeFoo ErrorCode = 1\n    ErrorCodeBar ErrorCode = 2\n)\n\ntype StructError struct {\n    Message string `json:"message,omitempty"`\n    Code ErrorCode `json:"errorCode"`\n}\n\nfunc (e *StructError) Error() string {\n    return e.Message\n}\n\ntype Service struct {\n    MightGoWrong() *StructError\n}\n'})}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:"language-typescript",metastring:'title="TypeScript"',children:"export enum ErrorCode {\n\tBar = 2,\n\tFoo = 1,\n}\n\nexport interface StructError {\n\tmessage?:string;\n\terrorCode:ErrorCode;\n}\n\nexport interface ServiceClient {\n    mightGoWrong(): Promise<StructError | null>;\n}\n"})})]})}function d(r={}){const{wrapper:e}={...(0,o.ah)(),...r.components};return e?(0,n.jsx)(e,{...r,children:(0,n.jsx)(p,{...r})}):p(r)}},3905:(r,e,t)=>{t.d(e,{ah:()=>l});var n=t(7294);function o(r,e,t){return e in r?Object.defineProperty(r,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):r[e]=t,r}function s(r,e){var t=Object.keys(r);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(r);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(r,e).enumerable}))),t.push.apply(t,n)}return t}function i(r){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?s(Object(t),!0).forEach((function(e){o(r,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(r,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(e){Object.defineProperty(r,e,Object.getOwnPropertyDescriptor(t,e))}))}return r}function c(r,e){if(null==r)return{};var t,n,o=function(r,e){if(null==r)return{};var t,n,o={},s=Object.keys(r);for(n=0;n<s.length;n++)t=s[n],e.indexOf(t)>=0||(o[t]=r[t]);return o}(r,e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(r);for(n=0;n<s.length;n++)t=s[n],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(r,t)&&(o[t]=r[t])}return o}var a=n.createContext({}),l=function(r){var e=n.useContext(a),t=e;return r&&(t="function"==typeof r?r(e):i(i({},e),r)),t},p={inlineCode:"code",wrapper:function(r){var e=r.children;return n.createElement(n.Fragment,{},e)}},d=n.forwardRef((function(r,e){var t=r.components,o=r.mdxType,s=r.originalType,a=r.parentName,d=c(r,["components","mdxType","originalType","parentName"]),u=l(t),g=o,h=u["".concat(a,".").concat(g)]||u[g]||p[g]||s;return t?n.createElement(h,i(i({ref:e},d),{},{components:t})):n.createElement(h,i({ref:e},d))}));d.displayName="MDXCreateElement"}}]);